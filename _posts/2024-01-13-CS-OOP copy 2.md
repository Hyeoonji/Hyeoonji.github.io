---
title: OneGrabSnapRotateTransformer
author: Nanda
date: 2024-01-13 11:45:00 +0900
categories: [Study, CS]
tags: [CS, Study, Unity, OOP]
---

```csharp

using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using Oculus.Interaction;
using System;

namespace Wintek.Content.Interaction.Grab
{
    /// <summary>
    /// A Transformer that rotates the target about an axis.
    /// Updates apply relative rotational changes of a GrabPoint about an axis.
    /// The axis is defined by a pivot transform: a world position and up vector.
    /// </summary>
    public class OneGrabSnapRotateTransformer : MonoBehaviour, ITransformer
    {

        [SerializeField, Optional]
        private Transform _pivotTransform = null;

        public Transform Pivot => _pivotTransform != null ? _pivotTransform : transform;

        [SerializeField]
        private RotateExtensions.Axis _rotationAxis = RotateExtensions.Axis.Up;

        public RotateExtensions.Axis RotationAxis => _rotationAxis;

        [SerializeField]
        private RotateExtensions.StartRotation _startRotationValue = RotateExtensions.StartRotation.Current;

        public RotateExtensions.StartRotation StartRotationValue => _startRotationValue;

        [Serializable]
        public class OneGrabRotateConstraints
        {
            public FloatConstraint MinAngle;
            public FloatConstraint MaxAngle;
        }

        [SerializeField]
        private OneGrabRotateConstraints _constraints =
            new OneGrabRotateConstraints()
            {
                MinAngle = new FloatConstraint(),
                MaxAngle = new FloatConstraint()
            };

        public OneGrabRotateConstraints Constraints
        {
            get
            {
                return _constraints;
            }

            set
            {
                _constraints = value;
            }
        }

        public float rotationClamp = 5f;
        private float _relativeAngle = 0.0f;
        private float _constrainedRelativeAngle = 0.0f;

        private IGrabbable _grabbable;
        private Vector3 _grabPositionInPivotSpace;
        private Pose _transformPoseInPivotSpace;

        private Pose _worldPivotPose;
        private Vector3 _previousVectorInPivotSpace;

        private Quaternion _localRotation;
        private float _startAngle = 0;
        private float _startZeroRotation = 0;

        public void Initialize(IGrabbable grabbable)
        {
            _grabbable = grabbable;
        }

        public Pose ComputeWorldPivotPose()
        {
            if (_pivotTransform != null)
            {
                return _pivotTransform.GetPose();
            }

            var targetTransform = _grabbable.Transform;

            Vector3 worldPosition = targetTransform.position;
            Quaternion worldRotation = targetTransform.parent != null
                ? targetTransform.parent.rotation * _localRotation
                : _localRotation;

            return new Pose(worldPosition, worldRotation);
        }

        public void BeginTransform()
        {
            var grabPoint = _grabbable.GrabPoints[0];
            var targetTransform = _grabbable.Transform;

            if (_pivotTransform == null)
            {
                _localRotation = targetTransform.localRotation;
            }

            Vector3 localAxis = Vector3.zero;
            localAxis[(int)_rotationAxis] = 1f;

            _worldPivotPose = ComputeWorldPivotPose();
            Vector3 rotationAxis = _worldPivotPose.rotation * localAxis;

            Quaternion inverseRotation = Quaternion.Inverse(_worldPivotPose.rotation);

            Vector3 grabDelta = grabPoint.position - _worldPivotPose.position;
            // The initial delta must be non-zero between the pivot and grab location for rotation

            if (Mathf.Abs(grabDelta.magnitude) < 0.001f)
            {
                Vector3 localAxisNext = Vector3.zero;
                localAxisNext[((int)_rotationAxis + 1) % 3] = 0.001f;
                grabDelta = _worldPivotPose.rotation * localAxisNext;
            }

            _grabPositionInPivotSpace =
                inverseRotation * grabDelta;

            Vector3 worldPositionDelta =
                inverseRotation * (targetTransform.position - _worldPivotPose.position);

            Quaternion worldRotationDelta = inverseRotation * targetTransform.rotation;
            _transformPoseInPivotSpace = new Pose(worldPositionDelta, worldRotationDelta);

            Vector3 initialOffset = _worldPivotPose.rotation * _grabPositionInPivotSpace;
            Vector3 initialVector = Vector3.ProjectOnPlane(initialOffset, rotationAxis);
            _previousVectorInPivotSpace = Quaternion.Inverse(_worldPivotPose.rotation) * initialVector;

            if (_startRotationValue == RotateExtensions.StartRotation.ZeroRotation)
            {
                _constrainedRelativeAngle = 0;
                _startZeroRotation = targetTransform.localEulerAngles[(int)_rotationAxis];

                if (Constraints.MinAngle.Constrain && Constraints.MaxAngle.Constrain)
                {
                    if (Constraints.MaxAngle.Value < _startZeroRotation && _startZeroRotation > 180)
                    {
                        _startZeroRotation -= 360;
                    }
                    if (Constraints.MinAngle.Value > _startZeroRotation && _startZeroRotation < -180)
                    {
                        _startZeroRotation += 360;
                    }
                }
            }

            _startAngle = _constrainedRelativeAngle;
            _relativeAngle = _startAngle;

            float parentScale = targetTransform.parent != null ? targetTransform.parent.lossyScale.x : 1f;
            _transformPoseInPivotSpace.position /= parentScale;
        }

        public void UpdateTransform()
        {
            var grabPoint = _grabbable.GrabPoints[0];
            var targetTransform = _grabbable.Transform;

            Vector3 localAxis = Vector3.zero;
            localAxis[(int)_rotationAxis] = 1f;
            _worldPivotPose = ComputeWorldPivotPose();
            Vector3 rotationAxis = _worldPivotPose.rotation * localAxis;

            // Project our positional offsets onto a plane with normal equal to the rotation axis
            Vector3 targetOffset = grabPoint.position - _worldPivotPose.position;
            Vector3 targetVector = Vector3.ProjectOnPlane(targetOffset, rotationAxis);

            Vector3 previousVectorInWorldSpace =
                _worldPivotPose.rotation * _previousVectorInPivotSpace;

            // update previous
            _previousVectorInPivotSpace = Quaternion.Inverse(_worldPivotPose.rotation) * targetVector;

            float signedAngle =
                Vector3.SignedAngle(previousVectorInWorldSpace, targetVector, rotationAxis);

            _relativeAngle += signedAngle;
            _constrainedRelativeAngle = _relativeAngle;
            //Debug.Log("_constrainedRelativeAngle " + _constrainedRelativeAngle);

            Quaternion deltaRotation;
            if (_startRotationValue == RotateExtensions.StartRotation.ZeroRotation)
            {
                float totalAngle = _constrainedRelativeAngle + _startZeroRotation;

                if (Constraints.MinAngle.Constrain)
                {
                    totalAngle = Mathf.Max(totalAngle, Constraints.MinAngle.Value);
                }
                if (Constraints.MaxAngle.Constrain)
                {
                    totalAngle = Mathf.Min(totalAngle, Constraints.MaxAngle.Value);
                }

                deltaRotation = Quaternion.AngleAxis(totalAngle - _startZeroRotation, rotationAxis);
            }
            else
            {
                if (Constraints.MinAngle.Constrain)
                {
                    _constrainedRelativeAngle = Mathf.Max(_constrainedRelativeAngle, Constraints.MinAngle.Value);
                }
                if (Constraints.MaxAngle.Constrain)
                {
                    _constrainedRelativeAngle = Mathf.Min(_constrainedRelativeAngle, Constraints.MaxAngle.Value);
                }
                deltaRotation = Quaternion.AngleAxis(_constrainedRelativeAngle - _startAngle, rotationAxis);
            }

            float parentScale = targetTransform.parent != null ? targetTransform.parent.lossyScale.x : 1f;
            Pose transformDeltaInWorldSpace =
                new Pose(
                    _worldPivotPose.rotation * (parentScale * _transformPoseInPivotSpace.position),
                    _worldPivotPose.rotation * _transformPoseInPivotSpace.rotation);

            Pose transformDeltaRotated = new Pose(
                deltaRotation * transformDeltaInWorldSpace.position,
                deltaRotation * transformDeltaInWorldSpace.rotation);

            targetTransform.position = _worldPivotPose.position + transformDeltaRotated.position;

            var currentEulerRotation = transformDeltaRotated.rotation.eulerAngles;
            //여기값에서 문제 발생하는 것으로 예측되는 중.
            targetTransform.rotation = Quaternion.Euler(currentEulerRotation);
            targetTransform.localRotation = Quaternion.Euler(targetTransform.localEulerAngles - new Vector3(targetTransform.localEulerAngles.x % rotationClamp, targetTransform.localEulerAngles.y % rotationClamp, targetTransform.localEulerAngles.z % rotationClamp));
            //Quaternion.Euler(currentEulerRotation - new Vector3(currentEulerRotation.x % rotationClamp, currentEulerRotation.y % rotationClamp, currentEulerRotation.z % rotationClamp));
            //transformDeltaRotated.rotation;
        }

        public void EndTransform()
        {
        }

        #region Inject

        public void InjectOptionalPivotTransform(Transform pivotTransform)
        {
            _pivotTransform = pivotTransform;
        }

        public void InjectOptionalRotationAxis(RotateExtensions.Axis rotationAxis)
        {
            _rotationAxis = rotationAxis;
        }

        public void InjectOptionalConstraints(OneGrabRotateConstraints constraints)
        {
            _constraints = constraints;
        }
        public void InjectOptionalClamp(float clamp)
        {
            rotationClamp = clamp;
        }
        public void InjectOptionalStartRotationValue(RotateExtensions.StartRotation startRotation)
        {
            _startRotationValue = startRotation;
        }

        #endregion
    }
}


```

