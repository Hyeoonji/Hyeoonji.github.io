---
title: VRGrabProperty
author: Nanda
date: 2024-01-13 11:45:00 +0900
categories: [Study, CS]
tags: [CS, Study, Unity, OOP]
---

```csharp

using Oculus.Interaction;
using Sirenix.OdinInspector;
using UnityEngine;
using Unity.Linq;
using UnityEngine.UIElements;
using Oculus.Interaction.DistanceReticles;
using Oculus.Interaction.HandGrab;
using Wintek.VR.Public;
using Wintek.Content.Node;
using static Wintek.Content.Interaction.Grab.OneGrabSnapRotateTransformer;
using Wintek.Content.Manager;
using Wintek.VR.Manager;
using System.Linq;
using Wintek.Content.Interaction.Grab;

namespace Wintek.Content.Public
{
    /// <summary>
    /// VR의 HandGrab에 관한 기본 세팅을 설정
    /// </summary>
    public class VRGrabProperty : GrabProperty
    {
        [Header("ObjectInfo")]
        private Rigidbody _rigidbody;
        public Rigidbody Rigidbody
        {
            get
            {
                if (_rigidbody == null)
                    _rigidbody = this.gameObject.GetComponent<Rigidbody>();
                return _rigidbody;
            }
        }

        bool isInit = false;
        bool isFinishing = false;

        [Header("GrabInfo")]
        public Grabbable grabbable;
        public GrabFreeTransformer grabFreeTransformer;
        public HandGrabInteractable handGrabInteractable;
        public DistanceHandGrabInteractable distanceHandGrabInteractable;

        [Button]
        public override void OnInitSetting()
        {
            if (isInit) return;

            isInteractable = false;
            isSettingFin = false;

            if (grabFreeTransformer == null)
            {
                this.grabFreeTransformer = gameObject.AddComponent<GrabFreeTransformer>();
            }

            grabbable = this.gameObject.AddComponent<Grabbable>();
            grabbable.enabled = false;
            grabbable.TransferOnSecondSelection = true; //이 속성을 선택하면, 한 손으로 물체를 잡은 다음 다른 손으로 잡는 경우, 원래 잡고 있던 손이 강제로 오브젝트를 놓게 됩니다. 
            grabbable.InjectOptionalKinematicWhileSelected(true);
            grabbable.InjectOptionalThrowWhenUnselected(false);
            grabbable.InjectOptionalTargetTransform(this.transform);
            grabbable.InjectOptionalOneGrabTransformer(grabFreeTransformer);
            grabbable.InjectOptionalTwoGrabTransformer(grabFreeTransformer);
            var movementProvider = this.gameObject.AddComponent<MoveFromTargetProvider>();
            handGrabInteractable = this.gameObject.AddComponent<HandGrabInteractable>();
            handGrabInteractable.enabled = false;
            handGrabInteractable.InjectOptionalPointableElement(grabbable);
            handGrabInteractable.InjectOptionalData(null);
            handGrabInteractable.InjectOptionalMovementProvider(movementProvider);

            var distanceObj = this.transform.Find("Distance Grab");
            if (distanceObj != null)
            {
                distanceHandGrabInteractable = distanceObj.gameObject.AddComponent<DistanceHandGrabInteractable>();
                distanceHandGrabInteractable.enabled = false;
                distanceHandGrabInteractable.InjectOptionalPointableElement(grabbable);

                distanceHandGrabInteractable.InjectOptionalData(null);
                distanceHandGrabInteractable.InjectOptionalMovementProvider(movementProvider);

                var reticleIcon = distanceHandGrabInteractable.gameObject.AddComponent<ReticleDataIcon>();
                reticleIcon.Snappiness = 1.0f;
            }
            RigidiBodyAdd();
            isInit = true;
        }

        [Button]
        public override void StartGrabbale()
        {
            if ((ContentManager.Instance as ContentManager).IsObserver()) return;

            base.StartGrabbale();

            SetGrabbableTarget(grabbable);
            grabbable.enabled = true;
            EnableChangeInteractable(true);
            foreach (var item in this.gameObject.Descendants().OfComponent<VRGrabProperty>())
            {
                item.EnableChangeInteractable(true);
                item.SetGrabbableTarget(grabbable);
            }
        }
        private void EnableChangeInteractable(bool isEnable)
        {
            handGrabInteractable.enabled = isEnable;

            if (handGrabInteractable.Interactors != null)
            {
                if (handGrabInteractable.Interactors != null)
                {
                    for (int i = handGrabInteractable.Interactors.Count - 1; i > -1; i--)
                    {
                        handGrabInteractable.RemoveInteractor(handGrabInteractable.Interactors.ElementAt(i));
                    }
                }
            }

            if (distanceHandGrabInteractable != null)
            {
                distanceHandGrabInteractable.enabled = isEnable;

                if (distanceHandGrabInteractable.Interactors != null)
                {
                    for (int i = distanceHandGrabInteractable.Interactors.Count - 1; i > -1; i--)
                    {
                        distanceHandGrabInteractable.RemoveInteractor(distanceHandGrabInteractable.Interactors.ElementAt(i));
                    }

                }

            }

        }
        public void SetGrabbableTarget(Grabbable _target)
        {

            handGrabInteractable.InjectOptionalPointableElement(_target);
            if (distanceHandGrabInteractable != null)
                distanceHandGrabInteractable.InjectOptionalPointableElement(_target);
            //   grabbable.InjectOptionalTargetTransform(_target.Transform);
        }
        private void RigidiBodyAdd()
        {
            if (Rigidbody == null)
            {
                _rigidbody = this.gameObject.AddComponent<Rigidbody>();

                _rigidbody.isKinematic = true;
                _rigidbody.useGravity = false;
                _rigidbody.collisionDetectionMode = CollisionDetectionMode.Continuous; //ContinuousSpeculative;
            }

            grabbable.InjectOptionalRigidbody(Rigidbody);
            handGrabInteractable.InjectRigidbody(Rigidbody);
            if (distanceHandGrabInteractable != null)
                distanceHandGrabInteractable.InjectRigidbody(Rigidbody);
        }
        private void RigidbodyDestroy()
        {
            if (Rigidbody != null)
            {
                var rigidbodyLocker = GetComponent<RigidbodyKinematicLocker>();
                if (rigidbodyLocker != null)
                    Destroy(rigidbodyLocker);
                Destroy(Rigidbody);
            }
        }

        [Button]
        public override void FinishGrabbalbe()
        {
            base.FinishGrabbalbe();

            (InteractorEventManager.Instance as VRInteractorEventManager).UnHover(this.gameObject);
            SetGrabbableTarget(grabbable);
            EnableChangeInteractable(false);
            GrababbleInit();
            grabbable.enabled = false;
            isSettingFin = false;

            foreach (var item in this.gameObject.Descendants().OfComponent<VRGrabProperty>())
            {
                item.EnableChangeInteractable(false);
                item.SetGrabbableTarget(item.grabbable);
            }
        }

        private OneGrabSnapRotateTransformer snapRotateTransformer;
        public override void OnRotateSetting(RotateExtensions.RotateTransformSaver _rotateTransform, GameObject _pivot)
        {
            if (isSettingFin) return;
            #region OneGrabSnapRotateTransformer Setting

            if (snapRotateTransformer == null)
                snapRotateTransformer = this.gameObject.AddComponent<OneGrabSnapRotateTransformer>();

            OneGrabRotateConstraints targetAxis = new OneGrabRotateConstraints()
            {
                MinAngle = new FloatConstraint()
                {
                    Constrain = _rotateTransform.minAngleConstrain,
                    Value = _rotateTransform.minAngle
                },
                MaxAngle = new FloatConstraint()
                {
                    Constrain = _rotateTransform.maxAngleConstrain,
                    Value = _rotateTransform.maxAngle
                }
            };

            snapRotateTransformer.InjectOptionalPivotTransform(_pivot.transform);
            snapRotateTransformer.InjectOptionalRotationAxis(_rotateTransform.axis);
            snapRotateTransformer.InjectOptionalConstraints(targetAxis);
            snapRotateTransformer.InjectOptionalClamp(_rotateTransform.Rotationclamp);
            snapRotateTransformer.InjectOptionalStartRotationValue(_rotateTransform.startRotation);
            grabbable.InjectOptionalOneGrabTransformer(snapRotateTransformer);
            grabbable.InjectOptionalTwoGrabTransformer(null);
            snapRotateTransformer.Initialize(grabbable);
            #endregion
            isSettingFin = true;
        }

        public void GrababbleInit()
        {
            if (grabFreeTransformer != null)
            {
                grabbable.InjectOptionalOneGrabTransformer(grabFreeTransformer);
                grabbable.InjectOptionalTwoGrabTransformer(grabFreeTransformer);
                grabFreeTransformer.Initialize(grabbable);
            }
        }

    }
}


```

